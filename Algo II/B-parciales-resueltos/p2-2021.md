### 1) (Voraz)
- Tenés la posibilidad de irte N días (con sus respectivas noches) de viaje y en el recorrido que armaste, c/dia/noche i estarás en una ciudad C_i. Contás con M pesos en total de presupuesto para gastar en alojamiento y para cada ciudad conoces el costo k_i por noche del unico hotel que tiene. Cada noche i podés elegir entre dormir en el hotel de la ciudad, lo que costará k_i, o dormir en una carpa que llevaste, que cuesta 0. Se pide indicar en qué ciudades dormirás en hotel, de manera tal que el monto total gastado en alojamiento en los N dias no supere el presupuesto M, minimizando la cantidad de noches que dormis en carpa. Para ello:

##### a) Criterio de selección:
- Elegir las noches con hotel más barato primero, hasta que se agote el presupuesto. 

##### b) Estructura de datos:
- Se recibe un natural M indicando el presupuesto total y un arreglo de tuplas, c:array[1..n] of Ciudad, donde el tipo Ciudad esta definido como:
~~~
type Ciudad = tuple
                C: Nat //Noche que se estará en esa ciudad
                K: Nat //Costo del hotel de dicha ciudad
              end tuple
~~~
- Se devuelve una lista hoteles: List of Ciudad, indicando en que ciudades SI se dormirá en hotel.

##### c) Funcionamiento:
- Se ordena de manera creciente el arreglo recibido segun el costo K con el algoritmo de ordenacion por inserción. Una vez ordenado, se recorre el arreglo de izquierda a derecha y si el elemento del arreglo en la posicion en la que estoy parado cumple que su campo costo es <= al presupuesto restante, entonces se añade por derecha dicho elemento a la lista.

##### d) Algoritmo:

````C
type Ciudad = tuple
                C: Nat
                K: Nat 
              end tuple

fun hoteles(c: array[1..n] of Ciudad, m: Nat) ret hoteles: List of Ciudad
    var presup: Nat
    presup := m
    insertion_sort_mod(c)
    hoteles := empty_list()
    for i := 1 to n do
        if(a[i].K <= presup) then
            addr(a[i].K)
            presup := presup - a[i].K
        fi
    od
end fun

proc insertion_sort_mod(in/out a:array[1..n] of Ciudad)
    for i:= 2 to n do
        insert(a, i)
    od
end proc

proc insert(in/out a: array[1..n] of Ciudad, in i: Nat)
    var j: Nat
    j := i
    while (j>1 ^ a[j].K < a[j-1].K) do
        swap(a, j-1, j)
        j := j-1
    od 
end proc

proc swap(in/out a:array[1..n] of Ciudad, in j:Nat, in m:Nat)
    var tmp: Ciudad
    tmp := a[j]
    a[j] := a[m]
    a[m] := tmp
end proc
````
