### 1) (Voraz)
- Un colectivero conduce un colectivo que solo puede llevar un pasajero. Su recorrido va desde la parada 1 hasta n y pasando por las paradas intermedias. Hay m pasajeros esperando; para cada pasajero i sabemos en que parada se subiría s_i y en cual se bajaría. 
Se debe trasladar la mayor cantidad de pasajeros posible. Aunque no se tiene la obligacion de siempre subir a alguien, podria darse el caso de que el chofer elija no subir a alguien para poder subir a alguien mas.
Se debe obtener el numero maximo de pasajeros trasladables en un unico viaje.

##### a) Criterio de selección:
> En cada paso, se debe seleccionar al pasajero que se baja mas temprano entre todos los pasajeros que aun puede recoger (es decir, que su parada de subida >= a la parada actual)

##### b) Est. de datos:
> c : Set of Pasajero como conjunto de entrada, donde Pasajero es una tupla definida como:
~~~
type Pasajero = tuple 
                    ps : Nat
                    pb : Nat
                end tuple
~~~
> Y se devolverá un natural res, indicando el nro maximo de pasajeros trasladables dado c.

##### c) Funcionamiento:
> Se lleva una cuenta de la parada actual, la cual se actualizará en base a la parada de bajada del pasajero recogido o bien se incrementa en 1 en caso de no subir a nadie. 
La iteración es mientras la parada actual no sea N, se buscará en el conjunto el pasajero con la MENOR parada de bajada; si dicho pasajero NO se sube en la parada actual, simplemente se actualiza a la siguiente parada (+1) y se repite el proceso. En caso de que dicho pasajero SI se suba en la actual, se suma al contador de pasajeros subidos (+1), se elimina dicho pasajero del conjunto y se actualiza la parada actual a la parada de bajada del pasajero a bordo. Y así hasta N.

##### d) Algoritmo:
````c
type Pasajero = tuple 
                    ps : Nat
                    pb : Nat
                end tuple

fun(c: Set of Pasajero) ret res: Nat
    var c2: Set of Pasajero
    c2 := copy_set(c)
    var parada_actual: Nat
    var min_pas: Pasajero
    parada_actual := 1
    var res_aux: Nat
    res_aux := 0
    while(parada_actual < n && not is_empty_set(c2)) do
        min_pas := get_min_pasajero(c2, parada_actual)
        if(min_pas.ps = parada_actual) then
            parada_actual := min_pas.pb
            res_aux := res_aux + 1
            elim(min_pas, c2)
        else 
            parada_actual := parada_actual + 1
        fi
    od
    destroy_set(c2)
    res := res_aux
end fun

fun get_min_pasajero(c: Set of Pasajero, parada_actual: Nat) ret pas: Pasajero
    var c2: Set of Pasajero
    c2 := copy_set(c)
    var min_aux: Nat
    min_aux := Infinito
    pas_aux: Pasajero
    res_temp: Pasajero
    while(not is_empty_set(c2)) do
        pas_aux := get_elem(c2)
        if(pas_aux.pb < min_aux && pas_aux.ps < parada_actual) then
            min_aux := pas_aux.pb
            res_temp := pas_aux
        fi
        elim(pas_aux, c2)
    od
    res := res_temp
    destroy_set(c2)
end fun 
````
### 2) (Backtracking)
- El presidente de tu país te acaba de elegir como asesor para tomar una serie de medidas de producción que mejoren la situacion economica. En el analisis se proponen n medidas, donde cada medida i pert {1, ..., n} producira una mejora de m_i puntos, m_i>0. También se analizó p/cada una el nivel de daño ecologico d_i que producirá, donde d_i > 0. El puntaje que tendrá cada medida i está dado por la relación m_i/d_i.
Se debe determinar cual es el maximo puntaje obtenible eligiendo K medidas, K < n, de manera que la suma del daño ecológico no sea mayor a C.

##### a) Qué calcula la función rec. y que argumentos recibe:
> maxPuntaje(i, k, c) calcula el mayor puntaje obtenible eligiendo k medidas entre 1,..., i a disposicion; de forma tal que la suma del daño ecológico no sea mayor a c.
> - i: Nat //Cantidad de medidas a disposicion
> - k: Nat //Cantidad de medidas que debo elegir
> - c: Cantidad de daño ecologico que no debo superar
##### b) Llamada principal:
>maxPuntaje(n, K, C)

##### c) Definición:
$$
\text{maxPuntaje}(i, k, c) = 
\begin{cases}
  0       & \text{si }   k=0 \\
  -\infty & \text{si }   i=0 \wedge k>0 \\
  \text{maxPuntaje}(i-1, k, c) & \text{si } (i>0) \wedge (d_i > c) \wedge (k>0)\\
  \max\big(m_i/d_i + \text{maxPuntaje}(i-1, k - 1, c-d_i),\ \text{maxPuntaje}(i-1, k, c)\big)
  & \text{si } (d_i \leq c) \wedge (i > 0) \wedge (k > 0) \\
\end{cases}
$$
