### 1) (Voraz)
- Un colectivero conduce un colectivo que solo puede llevar un pasajero. Su recorrido va desde la parada 1 hasta n y pasando por las paradas intermedias. Hay m pasajeros esperando; para cada pasajero i sabemos en que parada se subiría s_i y en cual se bajaría. 
Se debe trasladar la mayor cantidad de pasajeros posible. Aunque no se tiene la obligacion de siempre subir a alguien, podria darse el caso de que el chofer elija no subir a alguien para poder subir a alguien mas.
Se debe obtener el numero maximo de pasajeros trasladables en un unico viaje.

##### a) Criterio de selección:
> En cada paso, se debe seleccionar al pasajero que se baja mas temprano entre todos los pasajeros que aun puede recoger (es decir, que su parada de subida >= a la parada actual)

##### b) Est. de datos:
> c : Set of Pasajero como conjunto de entrada, donde Pasajero es una tupla definida como:
~~~
type Pasajero = tuple 
                    ps : Nat
                    pb : Nat
                end tuple
~~~
> Y se devolverá un natural res, indicando el nro maximo de pasajeros trasladables dado c.

##### c) Funcionamiento:
> Se lleva una cuenta de la parada actual, la cual se actualizará en base a la parada de bajada del pasajero recogido o bien se incrementa en 1 en caso de no subir a nadie. 
La iteración es mientras la parada actual no sea N, se buscará en el conjunto el pasajero con la MENOR parada de bajada; si dicho pasajero NO se sube en la parada actual, simplemente se actualiza a la siguiente parada (+1) y se repite el proceso. En caso de que dicho pasajero SI se suba en la actual, se suma al contador de pasajeros subidos (+1), se elimina dicho pasajero del conjunto y se actualiza la parada actual a la parada de bajada del pasajero a bordo. Y así hasta N.

##### d) Algoritmo:
````c
type Pasajero = tuple 
                    ps : Nat
                    pb : Nat
                end tuple

fun(c: Set of Pasajero) ret res: Nat
    var c2: Set of Pasajero
    c2 := copy_set(c)
    var parada_actual: Nat
    var min_pas: Pasajero
    parada_actual := 1
    var res_aux: Nat
    res_aux := 0
    while(parada_actual < n && not is_empty_set(c2)) do
        min_pas := get_min_pasajero(c2, parada_actual)
        if(min_pas.ps = parada_actual) then
            parada_actual := min_pas.pb
            res_aux := res_aux + 1
            elim(min_pas, c2)
        else 
            parada_actual := parada_actual + 1
        fi
    od
    destroy_set(c2)
    res := res_aux
end fun

fun get_min_pasajero(c: Set of Pasajero, parada_actual: Nat) ret pas: Pasajero
    var c2: Set of Pasajero
    c2 := copy_set(c)
    var min_aux: Nat
    min_aux := Infinito
    pas_aux: Pasajero
    res_temp: Pasajero
    while(not is_empty_set(c2)) do
        pas_aux := get_elem(c2)
        if(pas_aux.pb < min_aux && pas_aux.ps < parada_actual) then
            min_aux := pas_aux.pb
            res_temp := pas_aux
        fi
        elim(pas_aux, c2)
    od
    res := res_temp
    destroy_set(c2)
end fun 
````
