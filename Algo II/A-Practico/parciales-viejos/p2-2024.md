### 1) Problema de los helados (Voraz)

#### Criterio de seleccion:
- Para los primeros M, selecciono los sabores con mayor puntaje entre los helados al agua. Si M < K, entonces una vez seleccionados los primeros M selecciono los helados con mayor puntaje (sean al agua o no), entre los sabores restantes.

#### Estructura de datos:
- Recibo dos naturales M y K, y un conjunto Set of Helado, donde el tipo Helado esta definido como:

type Helado = tuple 
                p : Nat //Puntaje del sabor
                a : Bool //¿Es al agua?
                i : Nat // Identificador del sabor (no se usa en el algo)
              end tuple 

#### Funcionamiento: 
> El algoritmo copia el conjunto recibido. Sólo si M > 0, entonces obtiene el sabor al agua con mayor puntaje, suma el mismo al puntaje total acumulado y lo elimina del conjunto copia. Este proceso se itera M veces.
Si K > M, el algoritmo obtiene el sabor con mayor puntaje del conjunto copia (indeptemente de si es al agua), suma su puntaje al total acumulado y lo elimina del conjunto. Este proceso se itera K-M veces. 

#### Algoritmo:
~~~
fun mayorPuntaje(h: Set of Helado, m : Nat, k : Nat) ret pt : Nat
    h2 : Set of Helado
    h2 := copy_set(h)
    i : Nat
    i := 0
    pt := 0
    maxSabor : Helado
    while(m > 0 ^ (i < m ^ not is_empty_set(h2))) do
        maxSabor := get_max_agua(h2)
        pt := pt + maxSabor.p
        elim(h2, maxSabor)
        i := i + 1
    od 
    i := 0 
    while(i < k-m ^ not is_empty_set(h2)) do
        maxSabor := get_max(h2)
        pt := pt + maxSabor.p
        elim(h2, maxSabor)
        i := i + 1
    od

    destroy_set(h2)
end fun 

fun get_max_agua(h : Set of Helado) ret max : Helado
    h2 : Set of Helado 
    h2 := copy_set(h)
    aux : Helado
    auxP : Int
    auxP := -1
    while(not is_empty_set(h2)) do 
        aux := get_elem(h2)
        if(aux.p > auxP ^ aux.a) then
            max := aux
            auxP := aux.p 
        fi
        elim(aux, h2)
    od 
    destroy_set(h2)
end fun

fun get_max(h : Set of Helado) ret max : Helado
    h2 : Set of Helado 
    h2 := copy_set(h)
    aux : Helado
    auxP : Int
    auxP := -1
    while(not is_empty_set(h2)) do 
        aux := get_elem(h2)
        if(aux.p > auxP) then
            max := aux
            auxP := aux.p
        fi
        elim(aux, h2)
    od 
    destroy_set(h2)
end fun

~~~

### 2) Problema de los helados (backtracking)
- Cada gusto de helado, ademas del pi, tiene tambien asignado un valor Ci de calorias.
- Se debe encontrar el mayor puntaje obtenido eligiendo K gustos de helado, sin superar el total de calorias C y eligiendo al menos M gustos al agua. 

#### i) Qué calcula la función?
- La funcion 
> maxPuntaje(i, k, m, c)
- calcula el mayor puntaje obtenible eligiendo k gustos de helado, entre 1, ..., i disponibles, con al menos m gustos al agua y sin superar las C calorias (dato).
> La llamada principal es maxValor(N, K, M, C)

#### iv) Definicion:

$$
\text{maxPuntaje}(i, k, m, c) = 
\begin{cases}
  0       & \text{si }   i=0 \wedge k=0 \wedge m = 0 \\
  -\infty & \text{si }   c<0 \vee (i=0 \wedge (k>0 \vee m>0)) \\
  -\infty & \text{si }   m>0 \wedge k = 0 \\
  \max\big(  
    \max( p_i + \text{maxPuntaje}(i-1, k - 1, m, c-c_i),\ p_i + \text{maxPuntaje}(i-1, k-1, m-1, c-c_i) ),\ 
    \text{maxPuntaje}(i-1, k, m, c)
  \big)
  & \text{si } i > 0 \wedge k > 0 
\end{cases}
$$

> inchequeable que esto ande